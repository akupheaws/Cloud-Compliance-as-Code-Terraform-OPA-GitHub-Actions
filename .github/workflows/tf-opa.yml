name: Terraform + OPA Compliance

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      apply:
        description: "Run terraform apply (only on main)"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]

permissions:
  contents: write   # needed for auto-commit of formatting

concurrency:
  group: tf-opa-${{ github.ref }}
  cancel-in-progress: false

env:
  TF_VERSION: "1.8.5"
  TF_WORKDIR: "./terraform"
  CONFTEST_VERSION: "v0.59.0"           # pin to avoid Rego v1 default in >=0.60
  TF_BACKEND_BUCKET: "policy-as-code-akuphe"   # <--- set your bucket
  TF_BACKEND_TABLE:  "policy-as-code"          # <--- set your lock table

jobs:
  # 1) Prepare remote backend (S3 + DynamoDB)
  backend_setup:
    name: Backend Setup (S3 + DynamoDB)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      - name: Ensure S3 backend & DynamoDB lock table
        shell: bash
        run: |
          set -euo pipefail
          BUCKET="$TF_BACKEND_BUCKET"
          TABLE="$TF_BACKEND_TABLE"
          REGION="${AWS_REGION:-${{ secrets.AWS_REGION }}}"

          echo "Checking S3 bucket: $BUCKET"
          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "Bucket exists."
          else
            if [ "$REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" \
                --create-bucket-configuration LocationConstraint="$REGION"
            fi
            echo "Created bucket $BUCKET"
          fi

          aws s3api put-bucket-versioning \
            --bucket "$BUCKET" --versioning-configuration Status=Enabled

          aws s3api put-bucket-encryption \
            --bucket "$BUCKET" \
            --server-side-encryption-configuration \
            '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'

          echo "Checking DynamoDB table: $TABLE"
          if aws dynamodb describe-table --table-name "$TABLE" >/dev/null 2>&1; then
            echo "Table exists."
          else
            aws dynamodb create-table \
              --table-name "$TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            echo "Created table $TABLE"
          fi

  # 2) Formatting job (auto-fix on PR; always enforce)
  fmt:
    name: Terraform Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # Auto-fix formatting for PRs, then commit changes
      - name: Terraform Format (auto-fix on PR)
        if: ${{ github.event_name == 'pull_request' }}
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform fmt -recursive

      - name: Commit formatted files (PR only)
        if: ${{ github.event_name == 'pull_request' }}
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: terraform fmt"
          file_pattern: |
            **/*.tf
            **/*.tfvars

      # Enforce formatting in all events (shows diff on failures)
      - name: Terraform Format Check
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform fmt -recursive -check -diff

  # 3) Plan job (depends on backend + fmt), uploads plan artifacts
  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [backend_setup, fmt]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform init -input=false -upgrade

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform plan -out plan.out

      - name: Export plan.json
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform show -json plan.out > plan.json

      - name: Upload plan artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tf-plan-and-policy-artifacts
          path: |
            ${{ env.TF_WORKDIR }}/plan.out
            ${{ env.TF_WORKDIR }}/plan.json
          retention-days: 7

  # 4) Policy check + optional gated apply
  policy_and_apply:
    name: OPA Policy Check (+ optional Apply)
    runs-on: ubuntu-latest
    needs: [plan]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      - name: Download plan artifacts
        uses: actions/download-artifact@v4
        with:
          name: tf-plan-and-policy-artifacts
          path: ${{ env.TF_WORKDIR }}

      - name: Install Conftest (pinned & robust)
        shell: bash
        run: |
          set -euo pipefail
          OS="Linux"
          ARCH="$(uname -m)"
          case "$ARCH" in
            x86_64|amd64) ARCH="x86_64" ;;
            aarch64|arm64) ARCH="arm64" ;;
            *) echo "Unsupported arch: $ARCH"; exit 1 ;;
          esac
          VER="${CONFTEST_VERSION#v}"
          ASSET="conftest_${VER}_${OS}_${ARCH}.tar.gz"
          URL="https://github.com/open-policy-agent/conftest/releases/download/${CONFTEST_VERSION}/${ASSET}"
          echo "Downloading $URL"
          curl -sSLf -o /tmp/conftest.tgz "$URL"
          tar -xzf /tmp/conftest.tgz -C /tmp
          sudo mv /tmp/conftest /usr/local/bin/conftest
          conftest --version

      - name: OPA Policy Check (Conftest)
        run: conftest test ${{ env.TF_WORKDIR }}/plan.json --policy policies/tfplan

      # Optional gated apply (manual trigger on main only)
      - name: Terraform Init (for apply)
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.apply == 'true' }}
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform init -input=false

      - name: Terraform Apply (gated)
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.apply == 'true' }}
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform apply -auto-approve plan.out
