name: Terraform + OPA Compliance

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      apply:
        description: "Run terraform apply (only on main)"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]

# Needed for auto-commit and artifacts
permissions:
  contents: write

concurrency:
  group: tf-opa-${{ github.ref }}
  cancel-in-progress: false

env:
  TF_VERSION: "1.8.5"
  TF_WORKDIR: "./terraform"
  # Pin Conftest before the v0.60+ Rego v1 default
  CONFTEST_VERSION: "v0.59.0"
  # >>> Set these to your actual backend names <<<
  TF_BACKEND_BUCKET: "policy-as-code-akuphe"
  TF_BACKEND_TABLE:  "policy-as-code"

jobs:
  plan_and_check:
    name: Terraform Plan + OPA Policy Check
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      # Ensure S3 bucket + DynamoDB table for remote backend exist (idempotent)
      - name: Ensure S3 backend & DynamoDB lock table
        shell: bash
        env:
          BUCKET: ${{ env.TF_BACKEND_BUCKET }}
          TABLE:  ${{ env.TF_BACKEND_TABLE }}
          REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail
          echo "Checking S3 bucket: $BUCKET"
          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "Bucket exists."
          else
            if [ "$REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" \
                --create-bucket-configuration LocationConstraint="$REGION"
            fi
            echo "Created bucket $BUCKET"
          fi
          aws s3api put-bucket-versioning \
            --bucket "$BUCKET" --versioning-configuration Status=Enabled
          aws s3api put-bucket-encryption \
            --bucket "$BUCKET" \
            --server-side-encryption-configuration \
            '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'

          echo "Checking DynamoDB table: $TABLE"
          if aws dynamodb describe-table --table-name "$TABLE" >/dev/null 2>&1; then
            echo "Table exists."
          else
            aws dynamodb create-table \
              --table-name "$TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            echo "Created table $TABLE"
          fi

      # Install Conftest (pinned & robust)
      - name: Install Conftest
        shell: bash
        run: |
          set -euo pipefail
          OS="Linux"
          ARCH="$(uname -m)"
          case "$ARCH" in
            x86_64|amd64) ARCH="x86_64" ;;
            aarch64|arm64) ARCH="arm64" ;;
            *) echo "Unsupported arch: $ARCH"; exit 1 ;;
          esac
          VER="${CONFTEST_VERSION#v}"
          ASSET="conftest_${VER}_${OS}_${ARCH}.tar.gz"
          URL="https://github.com/open-policy-agent/conftest/releases/download/${CONFTEST_VERSION}/${ASSET}"
          echo "Downloading $URL"
          curl -sSLf -o /tmp/conftest.tgz "$URL"
          tar -xzf /tmp/conftest.tgz -C /tmp
          sudo mv /tmp/conftest /usr/local/bin/conftest
          conftest --version

      # Auto-fix formatting on PRs, commit back to the branch
      - name: Auto format Terraform (PR only)
        if: ${{ github.event_name == 'pull_request' }}
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform fmt -recursive

      - name: Commit formatted files (PR only)
        if: ${{ github.event_name == 'pull_request' }}
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: terraform fmt"
          file_pattern: |
            **/*.tf
            **/*.tfvars

      # Always enforce formatting (shows diff on failures)
      - name: Terraform Format Check
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform fmt -recursive -check -diff

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform init -input=false -upgrade

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform plan -out plan.out

      - name: Export plan.json
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform show -json plan.out > plan.json

      - name: OPA Policy Check (Conftest)
        run: conftest test ${{ env.TF_WORKDIR }}/plan.json --policy policies/tfplan

      - name: Upload plan + artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tf-plan-and-policy-artifacts
          path: |
            ${{ env.TF_WORKDIR }}/plan.out
            ${{ env.TF_WORKDIR }}/plan.json
          retention-days: 7

      # Optional gated apply (only on manual run + main)
      - name: Terraform Apply (gated)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.apply == 'true' && github.ref == 'refs/heads/main' }}
        working-directory: ${{ env.TF_WORKDIR }}
        run: terraform apply -auto-approve plan.out
